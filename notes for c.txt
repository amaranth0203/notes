
mct 里边定义事件的 enum 时使用了宏控:
#define MCT_EVENT_GENERATE_ENUM(ENUM) ENUM,
#define MCT_EVENT_MODULE_ENUM_LIST(ADD_ENTRY)                                 \
  ADD_ENTRY(MCT_EVENT_MODULE_SET_STREAM_CONFIG)                               \
  ADD_ENTRY(MCT_EVENT_MODULE_SET_STREAM_CONFIG_FOR_FLASH)                     \
  ADD_ENTRY(MCT_EVENT_MODULE_IFACE_SET_STREAM_CONFIG)
typedef enum _mct_event_module_type {
  MCT_EVENT_MODULE_ENUM_LIST(MCT_EVENT_GENERATE_ENUM)
} mct_event_module_type_t;
在 typedef enum 中
MCT_EVENT_MODULE_ENUM_LIST会把参数
MCT_EVENT_GENERATE_ENUM按宏展开
替换掉每一个ADD_ENTRY
生成
MCT_EVENT_GENERATE_ENUM(MCT_EVENT_MODULE_SET_STREAM_CONFIG) MCT_.........
而MCT_EVENT_GENERATE_ENUM展开后又会生成
MCT_EVENT_MODULE_SET_STREAM_CONFIG, MCT_....
之后这些 MCT_EVENT 就被填充到了 typedef enum 之中
并且每个事件之间都有间隔
ps:
    这种方法无法躲开 grep cscope sis的"Lookup References"
    但是可以有效避免 ctags sis的ctrl+左键直接跳转

void* 很好用，注意转换类型即可
void* 可以直接转成 void** 用 :
    void* wbc ;
    void* event_data ;
    event_data = &wbc ;
    send( event ) ;
    process_event( event ) {
        *(void**)event_data = &data ;
    }
之后 wbc 指向了 data 


已知数组长度，使用gcc编译器，可以这样初始化数组：
uint32 tmp_02[3072] = { [0 ... 3071] = 1296 }  ;
0 和 ... 和 3071 之间必须有空格间隔

不带参数不带返回值:
typedef void* (*ar)() ;
void* (*qyh_test)() ; // ar qyh_test ; 
void* handle = dlopen( "libqyh.so" , RTLD_NOW ) ;
*(void **)(&qyh_test) = dlsym( handle , "qyh_test" ) ;
(void)qyh_test( ) ;

带参数带返回值:
typedef int ( *ar )( const char* ) ;
//int ( *qyh_test )( const char* ) ;
ar qyh_test ;
void* handle = dlopen( "libqyh.so" , RTLD_NOW ) ;
*( void ** )( &qyh_test ) = dlsym( handle , "qyh_test" ) ;
int result = qyh_test( "armitage" ) ;
ALOGE( "[+] wassup result : %d\n" , result ) ;




调用的dll文件要在%PATH%中

按字节读二进制文件的时候，buffer定义一定要加上 unsigned，即
unsigned char buff* = .....
否则最高位会被当成符号位。。

C11之后类似typeof的宏
_Generic( 'a', char: 1, int: 2, long: 3, default: 0)
返回值为2，因为char在C语言里边作为整数处理

(数制转换的时候活用sscanf)
test.c 0xA5的接收方法：
	unsigned int addr ;
	sscanf( argv[1] , "%x" , &addr ) ;

输出指针指向的地址使用%x有可能会报错
最好是使用%p

字符串操作：
char * buffer = malloc( sizeof( char ) * SIZE ) ; //之后可以进行 buffer = "test"; 之类的赋值
char buffer[SIZE] ; // 之后不能进行 buffer = "test"之类的赋值，只能现在直接初始化
于是字符串操作统一使用 memset 和 memcpy 来进行初始化和赋值 :
memset( buffer , 0 , SIZE ) ; //以0填充
memcpy( buffer , "wassup" , 6 ) ; //赋值wassup，长度为6（结尾的'\0'被砍掉）

文件操作
尽量使用 fseek fread fwrite （打开方式直接使用 "rwb+" 比较省事)
fread或者fwrite之前，一定要用fseek定位
File* fp ;
fp = fopen( "filename" , "rwb+" ) ;
fseek( fp , 2L , SEEK_SET ) ; //从偏移为2的地方开始读/写（第三个字节）（2L换成0L则从文件开头）
fread(  &buffer[1] , sizeof( unsigned char ) , 3 , fp ) ; //从上边fseek定位的位置，读取3个sizeof的大小，写入buffer[1]之后的地址之中
fseek( fp , 2L , SEEK_SET ) ; //从偏移为2的地方开始读/写（第三个字节）（2L换成0L则从文件开头）
fwrite( &buffer[1] , sizeof( unsigned char ) , 3 , fp ) ; //把buffer[1]之后的地址中3个sizeof的大小的内容，写入文件被fseek定位的位置中
fclose( fp ) ;

fprintf( stdout , "%s" , "wassup" ) ;
printf( "%s" , "wassup" ) ;
 - 以上两句代码等同效果

sprintf( buffer , "%x" , 256 ) ; //格式化输出到字符串之中
 - 可以读取文件信息修改之后先sprintf到buffer中，再逆序（大小字节序不同）写入文件中，用来修改文件头信息

函数指针:
void fun( ){ puts( "aaa" ) ; }
void (*fptr)( ) ;
fptr = fun ;
fptr() ;
可以嵌套在结构体里边( C++类的实现 ):
struct st
{
    int (*output)() ;
    char name[15] ;
}
int aa( char* st ){ printf( "%s" , st ) ; }
int main()
{
    struct st* test ;
    test = ( struct st* )malloc( sizeof( struct st ) ) ;
    test->output = aa ;
    memcpy( test->name , "qiyunhu" , sizeof( "qiyunhu" ) ) ;
    test->output( test->name ) ;
    return 0 ;
}

结构体指针(引用上边的例子):
test->output = aa ;
可以写成
(*test).output = aa ;


多次出现redefinition错误的时候记得看看有没有加上#ifndef _HEADER_FILE_H_宏
