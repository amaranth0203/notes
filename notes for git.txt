
cherry-pick 之前先 git pull --all 一下 ( 确保后边不冲突 )
之后切到需要 cherry-pick 的 branch 之后 git cherry-pick 069277405480bbf25e7263909fec4965c1aa3e1b
如果没有冲突 则继续下个 branch
如果有冲突 手动解决冲突 之后 git add . 再 git cherry-pick --continue 接着继续下个分支
之后 git pull origin --all

如果一开始没有 git pull --all 的话，之后 git push origin --all 
出现 ! [rejected] xxxx -> xxxx (non-fast-forward)
就必须切换到出现 rejected 的分支单独 pull 



git reset --soft HEAD~
之后就回到了准备 commit 的状态
git reset HEAD setPS1
git checkout -- setPS1
就去掉了上次的提交

当文件名出现 . 在开头 结尾 或者直接 ... 
windows     的 cmd 和 mintty 都不能解决的时候
            可以用 git-gui 鼠标点击解决- -
linux       就没有这个困扰了

设置远程分支
git branch --set-upstream vivo-priv origin/vivo-priv
git branch --set-upstream-to=origin/vivo-work-cygwin



添加 submodule 的时候
如果出现 'bundle/Vundle.vim' already exists in the index
可以使用 git ls-files --stage
来列出所有 index 对应的内容
之后再 git rm --cached 文件名即可

在 vim bundle 添加其他的插件之后
相当于 在 vimrc 中添加了一个 submodule
之后使用 git config -f .gitmodules submodule.bundle/vim-airline.branch master
来配置 submodule 到 .gitmodules 中
再手动添加 submodule 的 path( 相对 ) 和 url
之后 git submodule update --init 不提示错误即可
来到新的机器上边 git pull
git submodule init
git submodule update
即可


当删文件后出现很多个 deleted: xxxx 时
git ls-files --deleted -z | xargs -0 git rm
可以一次全部把删除的文件进行 git rm

列出和单个文件有关的所有commit
git log --follow xxx

当只想更新一个文件的时候
git fetch
git checkout    origin/vivo_qcom_LA.BR.1.3.2-04130-8976.0_msm8976    mm-camera2/media-controller/modules/sensors/chromatix/0308/chromatix_imx298/3A/zsl_preview/chromatix_imx298_zsl_preview_kafa79s90_bu64297.h


git remote show origin ( 只显示已经tracking 远程分支的branch )
可以看到
Local branches configured for 'git pull':
和
Local ref configured for 'git push':
也可以用 git branch -vv 简单查看 ( 无论是否 tracking 都会显示 )

stash特定的文件
git stash save -p xxxx
进入交互模式

打git patch :
git apply xxx.patch
git apply --help

想查看一个commit的修改
用 git show commit-id
如果只想看改了哪个文件
用 git show --name-status commit-id
或 git show --name-only commit-id

使用stash的时候
git stash save "this is a test"
以后再git stash list的时候会连通branch和添加的注释一同显示
stash@{0}: On qyh_local: this is a test

git stash pop之后
可以使用 git reset HEAD 将成功合并的文件放到unstage区
然后一个个diff，需要的就add，不需要的就checkout --
接着手动merge冲突的文件，add再提交之后就可以git stash drop删掉在栈顶的stash记录了

重命名当前分支
	git branch -m <newname>
重命名分支
	git branch -m <oldname> <newname>

git add xxx yyy zzz
git commit -m "..." xxx yyy zzz
就可以在一个commit-id里边只提交xxx yyy zzz三个文件


工作时使用gerrit+git的模式来管理代码
一开始对于一个项目，去scm里边使用repo下载代码
然后分各个仓库(很多的.git)

接着最好自己建一个branch，在上边进行自己的开发和修改测试
	git checkout -b qyh
等到要提交代码的时候，重新建一个用来下载服务器代码的server_branch
	git checkout -b server_branch remotes/origin/vivo_qcom_LA.BR.1.3.2-04130-8976.0_msm8976
	git pull
接着merge
(在server_branch上) 可以直接git merge qyh
也可以(最好是)使用cherry-pick来选择qyh上的commit来merge
	git cherry-pick --edit bbe1a69
(也可以不使用--edit参数，之后再修改commit的comment)
之后推送代码到gerrit上边
	git push origin HEAD:refs/for/vivo_qcom_LA.BR.1.3.2-04130-8976.0_msm8976
gerrit和git的不同之处主要在于gerrit在push的时候不是直接push到代码库里边去，而是要审核之后才会真正进入到代码库中
接着登陆gerrit添加代码仓库审核人进行审核即可

push的时候可能会失败，比如提示comment没有包含PDxxxx[B160101-xxx]在里边
这个时候可以使用git commit --amend -m "PDxxxx[B160101-xxx] xxxxxxxxx"来修改最后一次的提交comment
如果要修改更加早时的comment，可以使用git rebase -i commit-id来进行修改
之后比commit-id更加晚的提交都会被列出来（具体谷歌）






git revert commit-id : 撤销commit-id那一次的提交，然后作为一个新的commit来提交






查看远程库信息，使用git remote -v；

本地新建的分支如果不推送到远程，对其他人就是不可见的；

从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；

在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；

建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；

从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。



提交错了……如果此刻提交的人不多（只有我一个在操作……）可以酱紫……
git push -f origin d72c:master
把服务器上的master回滚到d72c上边来……


 - 小命令后边加-h可以查看简易帮助页面
 - 小命令后边加--help会打开网页查看详细手册

git config --global user.email "you@example.com"
git config --global user.name "Your Name"
 - 执行这两个命令之后才能commit
 - 可以使用 git config --list 查看所有配置

git init - 创建repo

git add a.txt
git add b.txt c.txt
git commit -m "add 3 files."
 - 添加之后提交

git status - 查看repo状态
	git status -s/--short
	git status -v/--verbose

git diff readme.txt - 查看修改前后区别

文件三种状态：
modified --(git add)--> staged --(git commit)--> committed
 - modified和staged都是红色感叹号，committed是绿色勾

git log --pretty=oneline
git log --oneline
 - 查看当前版本之前的版本（回退之后不能看到后边的版本）

git reflog
 - 查看HEAD指针的历史记录（查看命令历史）

git reset --hard HEAD^ - 回退一个版本
git reset --hard HEAD^^ - 回退两个版本
git reset --hard HEAD~4 - 回退4个版本（HEAD~0回退到当前版本）
git reset --hard xxxxxx - 回退到特定版本

git checkout -- readme.txt
 - 用来撤销modify（回到上一次 git add 或者 git commit状态）
 - The special "option" -- means "treat every argument after this point as a file name, no matter what it looks like." This is not Git-specific, it's a general Unix command line convention. Normally you use it to clarify that an argument is a file name rather than an option, e.g.
 - rm -f      # does nothing
 - rm -- -f   # deletes a file named "-f"
git reset HEAD readme.txt
 - 用来撤销git add（unstage）

文件三种状态：
raw(committed)  --(modify)--> modified  --(git add)--> staged  --(git commit)--> committed
raw(committed) <--(git checkout --)--  modified <--(git reset HEAD)-- staged 

git rm test.txt - 删除文件
 - 注意git rm 之后会直接删除资源管理器中的文件，后续操作(commit/reset/checkout --)可以按提示来进行（和git add）类比

git remote add origin_self git@github.com:amaranth0203/learning.vivo.git - 添加远程仓库amaranth0203/learning.vivo.git,并且命名为origin_self
git push -u origin_self master - 第一次推送分支时加上u（--set-upstream)可以关联本地和远程分支，提高后边推送时的速度
git push origin_self master - 之后推送最新修改

git clone git@github.com:amaranth0203/gitskills.git
 - 克隆远程仓库，会自己创建一个名为gitskills的文件夹，所以不用提前创建一个空文件夹来放置内容

git branch - 查看所有分支和当前所在分支
git branch dev - 创建dev分支
git checkout dev - 切换到dev分支
git checkout -b dev - 创建&切换到dev分支

git checkout master
git merge dev - 合并dev分支到当前分支（master）上（若没有冲突的话）
 - 成功合并的时候两个版本会共用，在merge的时候加上参数 --no-ff，会保留dev被合并掉的版本（用git log --pretty --oneline可以查看）

git branch -d dev - 删除dev（已经合并）分支
git branch -D <name> - 强制删除分支（不管是否合并过）
git log --oneline --graph
 - merge之后能看到合并路径

git stash
 - 保存工作现场（没commit，但是又需要切换到其他分支）
 - (save local changes)保存非committed状态的现场（保存序号规则：之前已经存好的现场序号+1，被保存的现场序号为0）
git stash list
 - 查看已经保存的现场
git stash apply
 - 相当于git stash apply stash@{0}
 - 恢复到上一个现场，若使用stash@{1}则是上上个
 - 不会删除现场，必须配合git stash drop使用
git stash drop
 - 删除stash@{0}
 - 不能删除比0大的现场
git stash pop
 - 相当于 git stash apply stash@{0} & git stash drop

git push origin branch-name
1 - success
2 - failed : git pull
    2.1 - fix conflict : git push origin branch-name
    2.2 - no tracking infomation : git branch --set-upstream branch-name origin/branch-name 之后 git pull

git tag test - 创建标签
git tag - 查看已经创建的标签
git show test - 查看标签的详细信息
git tag -d test - 删除信息


https://help.github.com/articles/remove-sensitive-data/
 - remove sensitive data